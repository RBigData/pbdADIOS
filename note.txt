sudo R CMD INSTALL pbdADIOS --configure-args="--with-adios-home=/opt/adios/1.10" --no-test-load
sudo R CMD REMOVE pbdADIOS

sudo R CMD INSTALL pbdADIOS --configure-args="--with-adios-home=/opt/adios/1.10" --no-test-load --clean
sudo R CMD REMOVE -l /usr/local/lib/R/site-library pbdADIOS

> .libPaths()
[1] "/home/pbdr/R/i686-pc-linux-gnu-library/3.3"
[2] "/usr/local/lib/R/site-library"             
[3] "/usr/lib/R/site-library"                   
[4] "/usr/lib/R/library"  

git clone https://github.com/YupingLu/pbdADIOS.git
R CMD INSTALL pbdADIOS --configure-args="--with-adios-home=/opt/adios/1.10" 
R CMD REMOVE pbdADIOS

need to change the NAMESPACE

This version is right?
git clone https://github.com/sgn11/pbdADIOS.git

Error: '.SPMD.CT' is not an exported object from 'namespace:pbdMPI'
sudo R CMD REMOVE -l /usr/local/lib/R/site-library pbdMPI
git clone https://github.com/RBigData/pbdMPI.git
R CMD INSTALL pbdMPI

Compile c source code
R CMD SHLIB tmp.c

在function内创建的pointer, use newRptr, otherwise use R_ExternalPtrAddr to get the pointer
Pay attention to finalizer and finalizer0
External pointer SEXPs are intended to handle references to C structures such as ‘handles’

difference between INTERGER and asInteger
zeroes <- cfunction(c(n_ = "integer"), '
  int n = asInteger(n_);

  SEXP out = PROTECT(allocVector(INTSXP, n));
  memset(INTEGER(out), 0, n * sizeof(int));

  UNPROTECT(1);

  return out;
')

// should us as.integer to convert double to int
zeroes1 <- cfunction(c(n_ = "integer"), '
  int* n = INTEGER(n_);

  SEXP out = PROTECT(allocVector(INTSXP, *n));
  memset(INTEGER(out), 0, (*n) * sizeof(int));

  UNPROTECT(1);

  return out;
')

zeroes2 <- cfunction(c(n_ = "integer"), '

  int* n = INTEGER(coerceVector(n_, INTSXP));

  SEXP out = PROTECT(allocVector(INTSXP, *n));
  memset(INTEGER(out), 0, (*n) * sizeof(int));

  UNPROTECT(1);

  return out;
')

te <- cfunction(c(n_ = "numeric"), '
  double n = asReal(n_);

  int a = n;
  return ScalarReal(a);
')

method to get communicator
comm = .pbd_env$SPMD.CT$comm


int adios_write (int64_t fd_p, const char * name, const void * var);
check

int adios_close (int64_t fd_p);
check

te <- cfunction(c(n_ = "numeric"), '
  double n = asReal(n_);
  n = 10;
  REAL(n_)[0] = n;
  return R_NilValue;
')

06/16/2016
Remember to support other types, i.e. String for read API

First pull new github files.
git reset --hard HEAD 
git clean -f 
git pull

or
rm -rf pbdADIOS
git clone https://github.com/YupingLu/pbdADIOS.git

steps to create shared library
1.
autoconf configure.ac && autoreconf -if
2.
./configure --with-adios-home=/opt/adios/1.10
3. 
R CMD SHLIB *.c

dyn.load('R_adios_read.so')
source("read.R")

R CMD build pbdADIOS 
R CMD check pbdADIOS_0.1-0.tar.gz 
R CMD INSTALL pbdADIOS --configure-args="--with-adios-home=/opt/adios/1.10" 
R CMD REMOVE pbdADIOS

learn when to use invisible

06/18/2016
learn to use git


abc <- cfunction(NULL, '
  SEXP out = PROTECT(allocVector(STRSXP, 3));
  char greeting[] = "Hello World";
  char greeting1[] = "This is my test";
  char greeting2[] = "lol";
  SET_STRING_ELT(out, 0, mkChar(greeting));
  SET_STRING_ELT(out, 1, mkChar(greeting1));
  SET_STRING_ELT(out, 2, mkChar(greeting2));

  UNPROTECT(1);

  return out;
')

The adios value is only interger, double etc? no string?


adios_get_attr

adios_get_attr_byid

test_
adios.set.max.buffersize(300)
adios.declare.group(groupname, "")
adios.define.var(adios_group_ptr, "T", "","adios_double", toString(my.dim), toString(g.dim), toString(my.start))

check adios r code, change parameters
mpirun -np 12 ./heat_transfer_adios1 heat  4 3    40 60   12 500



dummy <- cfunction(body = '
  SEXP out;

  int* number;
  number = (int *)malloc(5 * sizeof(int));
  for(int i=0; i<5; i++)
    number[i] = i;
  PROTECT(out = R_MakeExternalPtr(number, R_NilValue, R_NilValue)); 
  UNPROTECT(1);
  return out;
')

a = dummy()
a[1]
Error in a[1] : object of type 'externalptr' is not subsettable

06/25/2016
roxygen2::roxygenise()

06/26/2016
pbdr@pbdrVM:~/pbdrtest$ bpls -la heat.bp 
  integer  gndx                     6*scalar = 160 / 160 / 160 / 0
  integer  gndy                     6*scalar = 150 / 150 / 150 / 0
  integer  /info/nproc              6*scalar = 12 / 12 / 12 / 0
  integer  /info/npx                6*scalar = 4 / 4 / 4 / 0
  integer  /info/npy                6*scalar = 3 / 3 / 3 / 0
  integer  offx                     6*scalar = 0 / 120 / 60 / 44.7214
  integer  offy                     6*scalar = 0 / 100 / 50 / 40.8248
  integer  ndx                      6*scalar = 40 / 40 / 40 / 0
  integer  ndy                      6*scalar = 50 / 50 / 50 / 0
  integer  step                     6*scalar = 1 / 6 / 3.5 / 1.70783
  integer  iterations               6*scalar = 500 / 500 / 500 / 0
  double   T                        6*{150, 160} = 0.000212009 / 999.47 / 442.536 / 318.995
  double   dT                       6*{150, 160} = 6.27403e-06 / 0.720097 / 0.135503 / 0.115625
  string   /info/nproc/description  attr   = "Number of writers"
  string   /info/npx/description    attr   = "Number of processors in x dimension"
  string   /info/npy/description    attr   = "Number of processors in y dimension"
  string   T/description            attr   = "Temperature 2D array with 2D decomposition"
  string   dT/description           attr   = "delta T"
  
pbdr@pbdrVM:~/pbdrtest$ bpls -a heat.bp 
  integer  gndx                     6*scalar
  integer  gndy                     6*scalar
  integer  /info/nproc              6*scalar
  integer  /info/npx                6*scalar
  integer  /info/npy                6*scalar
  integer  offx                     6*scalar
  integer  offy                     6*scalar
  integer  ndx                      6*scalar
  integer  ndy                      6*scalar
  integer  step                     6*scalar
  integer  iterations               6*scalar
  double   T                        6*{150, 160}
  double   dT                       6*{150, 160}
  string   /info/nproc/description  attr
  string   /info/npx/description    attr
  string   /info/npy/description    attr
  string   T/description            attr
  string   dT/description           attr

07/02/2016
h5dump("myhdf5file.h5")

pbdr@pbdrVM:~/pbdrtest$ more dumptest.txt 
  integer  gndx         6*scalar
    (0)    160 160 160 160 160 160

  integer  gndy         6*scalar
    (0)    150 150 150 150 150 150

  integer  /info/nproc  6*scalar
    (0)    12 12 12 12 12 12

  integer  /info/npx    6*scalar
    (0)    4 4 4 4 4 4

  integer  /info/npy    6*scalar
    (0)    3 3 3 3 3 3

  integer  offx         6*scalar
    (0)    0 0 0 0 0 0

  integer  offy         6*scalar
    (0)    0 0 0 0 0 0

  integer  ndx          6*scalar
    (0)    40 40 40 40 40 40

  integer  ndy          6*scalar
    (0)    50 50 50 50 50 50

  integer  step         6*scalar
    (0)    1 2 3 4 5 6

  integer  iterations   6*scalar
    (0)    500 500 500 500 500 500

  double   T            6*{150, 160}
    (0,  0,  0)    996.827 993.67 990.545 987.465 984.447 981.503
    (0,  0,  6)    978.645 975.886 973.235 970.699 968.288 966.005
    (0,  0, 12)    963.854 961.839 959.959 958.215 956.605 955.126
    (0,  0, 18)    953.773 952.543 951.43 950.428 949.529 948.728
    (0,  0, 24)    948.018 947.39 946.839 946.358 945.939 945.577


dummy <- cfunction(body = '

  int* number;
  number = (int *)malloc(5 * sizeof(int));
  for(int i=0; i<5; i++)
    number[i] = i;

  SEXP out = PROTECT(allocVector(INTSXP, 5));
  for(int i=0; i<5; i++)
    INTEGER(out)[i] = number[i];

  free(number);
  UNPROTECT(1);
  return out;
')

a = dummy()
a[1]
0

07/03/2016
double   T            6*{150, 160}
    s[0]=0, c[0]=6, n=6
    s[1]=0, c[1]=150, n=900
    s[2]=0, c[2]=160, n=144000
 total size of data to read = 1152000
Read size strategy:
    dim 2: read 160 elements
    dim 1: read 150 elements
    dim 0: read 6 elements
    read 144000 elements at once, 144000 in total (nelems=144000)
    (0,  0,  0)    996.827 993.67 990.545 987.465 984.447 981.503
    (0,  0,  6)    978.645 975.886 973.235 970.699 968.288 966.005
    (0,  0, 12)    963.854 961.839 959.959 958.215 956.605 955.126
    (0,  0, 18)    953.773 952.543 951.43 950.428 949.529 948.728
    (0,  0, 24)    948.018 947.39 946.839 946.358 945.939 945.577
    (0,  0, 30)    945.265 944.998 944.77 944.577 944.414 944.277
    (0,  0, 36)    944.162 944.067 943.988 943.924 943.871 943.827
    (0,  0, 42)    943.792 943.764 943.741 943.723 943.709 943.698
    (0,  0, 48)    943.689 943.682 943.676 943.672 943.669 943.666
    (0,  0, 54)    943.664 943.663 943.662 943.661 943.66 943.66


     double   T            6*{150, 160}
    j=0, st=0 ct=6
    s[0]=0, c[0]=6, n=6
    j=1, st=0 ct=150
    s[1]=0, c[1]=150, n=900
    j=2, st=0 ct=160
    s[2]=0, c[2]=160, n=144000
 total size of data to read = 1152000
Read size strategy:
    dim 2: read 160 elements
    dim 1: read 150 elements
    dim 0: read 6 elements
    read 144000 elements at once, 144000 in total (nelems=144000)
adios_read_var name=T   start = { 0 0 0 }  count = { 6 150 160 }  read 144000 elems
    (0,  0,  0)    996.827 993.67 990.545 987.465 984.447 981.503
    (0,  0,  6)    978.645 975.886 973.235 970.699 968.288 966.005
    (0,  0, 12)    963.854 961.839 959.959 958.215 956.605 955.126
    (0,  0, 18)    953.773 952.543 951.43 950.428 949.529 948.728
    (0,  0, 24)    948.018 947.39 946.839 946.358 945.939 945.577


07/06/2016
1. dump version 1 read 10MB per loop
   dump version 2 read all at once
2. include complex later

SEXP vec = PROTECT(allocVector(VECSXP, 3));
SET_VECTOR_ELT(vec, 0, dbls);
SET_VECTOR_ELT(vec, 1, lgls);
SET_VECTOR_ELT(vec, 2, ints);









