sudo R CMD INSTALL pbdADIOS --configure-args="--with-adios-home=/opt/adios/1.10" --no-test-load
sudo R CMD REMOVE pbdADIOS

sudo R CMD INSTALL pbdADIOS --configure-args="--with-adios-home=/opt/adios/1.10" --no-test-load --clean
sudo R CMD REMOVE -l /usr/local/lib/R/site-library pbdADIOS

> .libPaths()
[1] "/home/pbdr/R/i686-pc-linux-gnu-library/3.3"
[2] "/usr/local/lib/R/site-library"             
[3] "/usr/lib/R/site-library"                   
[4] "/usr/lib/R/library"  

git clone https://github.com/YupingLu/pbdADIOS.git
R CMD INSTALL pbdADIOS --configure-args="--with-adios-home=/opt/adios/1.10" 
R CMD REMOVE pbdADIOS

need to change the NAMESPACE

This version is right?
git clone https://github.com/sgn11/pbdADIOS.git

Error: '.SPMD.CT' is not an exported object from 'namespace:pbdMPI'
sudo R CMD REMOVE -l /usr/local/lib/R/site-library pbdMPI
git clone https://github.com/RBigData/pbdMPI.git
R CMD INSTALL pbdMPI

Compile c source code
R CMD SHLIB tmp.c

在function内创建的pointer, use newRptr, otherwise use R_ExternalPtrAddr to get the pointer
Pay attention to finalizer and finalizer0
External pointer SEXPs are intended to handle references to C structures such as ‘handles’

difference between INTERGER and asInteger
zeroes <- cfunction(c(n_ = "integer"), '
  int n = asInteger(n_);

  SEXP out = PROTECT(allocVector(INTSXP, n));
  memset(INTEGER(out), 0, n * sizeof(int));

  UNPROTECT(1);

  return out;
')

// should us as.integer to convert double to int
zeroes1 <- cfunction(c(n_ = "integer"), '
  int* n = INTEGER(n_);

  SEXP out = PROTECT(allocVector(INTSXP, *n));
  memset(INTEGER(out), 0, (*n) * sizeof(int));

  UNPROTECT(1);

  return out;
')

zeroes2 <- cfunction(c(n_ = "integer"), '

  int* n = INTEGER(coerceVector(n_, INTSXP));

  SEXP out = PROTECT(allocVector(INTSXP, *n));
  memset(INTEGER(out), 0, (*n) * sizeof(int));

  UNPROTECT(1);

  return out;
')

te <- cfunction(c(n_ = "numeric"), '
  double n = asReal(n_);

  int a = n;
  return ScalarReal(a);
')

method to get communicator
comm = .pbd_env$SPMD.CT$comm


// To declare a ADIOS group
int adios_declare_group (int64_t * id, 
                         const char * name,
                         const char * time_index, 
                         enum ADIOS_FLAG stats
                        );
check


// To select a I/O method for a ADIOS group
int adios_select_method (int64_t group, 
                         const char * method,
                         const char * parameters,
                         const char * base_path
                        );
check


// To define a ADIOS variable
// Returns a variable ID, which can be used in adios_write_byid()
// 0 return value indicates an error
int64_t adios_define_var (int64_t group_id, 
                          const char * name,
                          const char * path,
                          enum ADIOS_DATATYPES type,
                          const char * dimensions,
                          const char * global_dimensions,
                          const char * local_offsets
                         );
check


// end user calls for each I/O operation
// modes = "r" = "read", "w" = "write", "a" = "append", "u" = "update"
int adios_open (int64_t * fd, 
                const char * group_name, 
                const char * name,
                const char * mode, 
                MPI_Comm comm
               );
check



int adios_group_size (int64_t fd_p, 
                      uint64_t data_size,
                      uint64_t * total_size
                     );
check

int adios_write (int64_t fd_p, const char * name, const void * var);
check

int adios_close (int64_t fd_p);
check

// To allocate ADIOS buffer OBSOLETE
int adios_allocate_buffer (
        enum ADIOS_BUFFER_ALLOC_WHEN adios_buffer_alloc_when,
        uint64_t buffer_size
        );


// To set maximum buffer size for each adios_open()...adios_close() operation.
void adios_set_max_buffer_size (uint64_t max_buffer_size_MB);







